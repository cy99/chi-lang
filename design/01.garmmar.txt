// parser与lexer纯手工实现，以下表示仅供参考，而不用于任何语法分析器的生成器。

// -------------------------------
// parser
// -------------------------------
ChiFile : Import* (StructDeclare | ValueDeclare | LambdaDeclare | ActorDeclare | EnumDeclare)*
Import : IMPORT Path;
Path : ID ('/' ID)*

StructDeclare : NATIVE? STRUCT ID GenericsParams? (':' StructParams) '{' StructBody '}';
StructParams : '(' StructParam (',' StructParam)* ')' ;
StructParam : ID ':' TypeName ;
StructBody : (SValueDecl | SLambdaDecl | SActorDecl)* ;
SValueDecl : VAL ValName ((':' TypeName) | (('=' | DEFAULT) ValueExp));
SLambdaDecl : Annotations? LAMBDA ID GenericsParams? (':' LambdaType)? (('=' | DEFAULT) Lambda)? ;
SActorDecl : (ACTOR | ACTORS) ID (':' LambdaType)? (('=' | DEFAULT) Lambda)? ;

GenericsParams : '[' ID (',' ID)* ']' ;

LambdaType : (LambdaTypeReturn | (LambdaTypeParams ('->' LambdaTypeReturn)?);
LambdaTypeParams : TypeName  | ('(' LambdaTypeParam (',' LambdaTypeParam)* ')') | '()';
LambdaTypeParam : TypeName | LambdaType ;
LambdaTypeReturn : TypeName | LambdaType ;
Lambda : (LambdaParams '->')? LambdaBody;
LambdaParams : ID | ('(' ID (',' ID)* ')') | '()';
LambdaBody : ValueExp | ('{' Statements'}');
Annotations : ('@' ID)+;

Statements : Statement+ ;
Statement : ValueDeclare | LambdaDeclare | ActorDeclare | ValueExp;

ValueDeclare : VAL ValName '=' ValueExp ;
LambdaDeclare : Annotations? NATIVE? LAMBDA ID GenericsParams? (':' LambdaType)? '=' Lambda ;
ActorDeclare : (ACTOR | ACTORS) ID (':' LambdaType)? '=' Lambda ;
EnumDeclare : ENUM ID '{' ID (',' ID)* '}' ;

TypeName : ID | ('[' ID (',' ID)* ']') | (TypeName '...' ) ; // 只有在做为参数时才可以用...的形式。
ValName : ID ;
ValueExp : ValName | IntValue | FloatValue | BoolValue | FieldCall | FunCall | CaseExp;
FunCall : (ID | FieldCall) ('(' ValueExp (',' ValueExp)* ')')?;
FieldCall : (ID | FieldCall) '.'? ID;
IntValue : INT;
FloatValue : FLOAT;
BoolValue : TRUE | FALSE ;
CaseExp : CaseValueWhenExp | CaseWhenBoolExp ;
CaseValueWhenExp : CASE ValName '{' CVWhen+ CElse '}'; // 如果ValName是Enum或Bool类型的，则不需要else部分，否则就一定要。 
CVWhen : WHEN ValueExp ':' LambdaBody ; // 这里的LambdaBody可以没有{}，
										// 同时alueExp只能是立即数（直接写在代码中的值，且是Int/Float/Bool/Char/String/enum之中的） 
										// 且所有的when后面的类型得是同一个类型的。
CaseWhenBoolExp : CASE '{' BoolWhen+ CElse '}';
BoolWhen : CVWhen ; // 这里BoolWhen和CVWhen的形式差不多，但when后面一定是一个Bool值，或运算结果是一个Bool值。
CElse : ELSE ':' LambdaBody ;

// -------------------------------
// lexer
// -------------------------------
INT : (+|-)? ((0[0-7]*) | (0('x'|'X')[0-9a-zA-Z]+) | ([1-9][0-9]*));
FLOAT : (+|-)? (\d+)? '.'? (\d+)? (('e'|'E') (+|-)? \d+)?; // 前面的数字部分不可以同时省略 
CHAR : '\'' 除换行和单引号之外的所有字符或转义字符 '\''
STRING : '"' 除换行和双引号之外的所有字符或转义字符(可以有多个) '"' ;
NATIVE : 'native' ;
STRUCT : 'struct' ;
VAL : 'val' ;
LAMBDA : 'lambda' ;
ACTOR : 'actor' ;
ACTORS : 'actors' ;
CASE : 'case' ;
WHEN : 'when' ;
ELSE : 'else' ;
SELF : 'self' ;
ENUM : 'enum' ;
IMPORT : 'import' ;
DEFAULT : 'default' ;
TRUE : 'true' ;
FALSE : 'false' ;
ARROW : '->' ;
BLANK : [\n\r\t ] ;
ASSIGNMENT : '=' ;
EQUALS : '==' ;
LBT : '(' ;
RBT : ')' ;
LSBT : '[' ;
RSBT : ']' ;
LBBT : '{' ;
RBBT : '}' ;
COLON : ':' ;
COMMA : ',' ;
DOT : '.' ;
SEMI : ';' ;
AT : '@' ;
ELLIPSIS : '...' ;
ID : [^;'",.@=()\[\]{}\s]+ 并且不是上面的其它关键字，并且如果有冒号则只能在开头，并且如果有数字则不能在开头;
