native struct Array[T] {
	lambda get : Integer -> T
	lambda length : Integer
	lambda findIndex : T -> Integer = obj -> _findIndex(self, obj, 0, length);
	lambda slice : (Integer, Integer) -> _Slice[T] = (from, to) -> case {
		when (from < to) && (from >= 0) && (to <= length) : _Slice(self, from to);
		else error("index out of range.");
	}
	lambda appendFront : T -> Array[T];
	lambda map[E] : (T -> E) -> Array[E] = f -> _map(f, 0);
	lambda _map[E] : (T -> E, Integer) = (f, i) -> case {
		when i == (length - 1) : Array(f(self.get(i));
		when i < length : _map(f, i + 1).appendFront(f(self.get(i)));
		else : error("index out of range.");
	}
}
lambda _findIndex[T] : (Array[T], T, Integer, Integer) -> Integer= (array, obj, from, to) -> {
	case {
		when from >= to : -1;
		when obj == array.get(from) : array.get(from);
		else : _findIndex(array, obj, from + 1);
	}
}

struct _Slice[T] {
	val _array : Array[T];
	val _from : Integer;
	val _to : Integer;
	@Lazy
	lambda length : Integer = _to - from;

	lambda get : Integer -> T = idx -> {
		case {
			when (idx < length) : _array.get(_from + idx);
			else : error("index out of range.");
		}
	}

	lambda findIndex : T -> Integer = obj -> {
		val idx = _findIndex(_array, obj, _from, _to);
		case idx {
			when -1 : -1;
			else _from + idx;
		}
	}

	lambda slice : (Integer, Integer) -> _Slice[T] = (from, to) -> case {
		when (from < to) && (from >= 0) && (to <= length) : _Slice(_array, _from + from, _from + from + to);
		else : error("index out of range.");
	}
}