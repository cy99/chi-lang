native struct Array[T] {
	lambda get : Int -> T
	lambda length : Int
	lambda findIndex : T -> Int = obj -> _findIndex(self, obj, 0, length);
	lambda slice : (Int, Int) -> _Slice[T] = (from, to) -> case {
		when (from < to) && (from >= 0) && (to <= length) : _Slice(self, from to);
		else error("index out of range.");
	}
	lambda subArray : (Int, Int) -> Array[T];
	lambda appendFront : T -> Array[T];
	lambda map[E] : (T -> E) -> Array[E] = f -> _map(f, 0);
	lambda _map[E] : (T -> E, Int) -> Array[E] = (f, i) -> case i {
		when length - 1 : Array(f(self.get(i));
		else _map(f, i + 1).appendFront(f(self.get(i)));
	}
	lambda filter : (T -> Boolean) -> Array[T] = f -> _filter(self, f, length - 1, Array[T]());
	lambda reduce[E] : (E, (E, T) -> E) -> E = // 未实现
	lambda forEach : (Int, (T)) = (idx, f) -> // 未实现
}
lambda _findIndex[T] : (Array[T], T, Int, Int) -> Int= (array, obj, from, to) -> {
	case {
		when from >= to : -1;
		when obj == array.get(from) : array.get(from);
		else : _findIndex(array, obj, from + 1);
	}
}
lambda _filter[T] : (Array[T], T -> Boolean, Int, Array[T]) -> Array[T] = (array, f, idx, res) -> case idx {
	when -1 : res;
	else case f(array get idx) {
		when true : _filter(array, f, idx - 1, res.appendFront(array get idx));
		when false : _filter(array, f, idx - 1, res);
	}
}

struct _Slice[T] {
	val _array : Array[T];
	val _from : Int;
	val _to : Int;
	@Lazy
	lambda length : Int = _to - from;

	lambda get : Int -> T = idx -> {
		case {
			when (idx < length) : _array.get(_from + idx);
			else : error("index out of range.");
		}
	}

	lambda findIndex : T -> Int = obj -> {
		val idx = _findIndex(_array, obj, _from, _to);
		case idx {
			when -1 : -1;
			else _from + idx;
		}
	}

	lambda slice : (Int, Int) -> _Slice[T] = (from, to) -> case {
		when (from < to) && (from >= 0) && (to <= length) : _Slice(_array, _from + from, _from + from + to);
		else : error("index out of range.");
	}
}