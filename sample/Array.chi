native struct Array[T] {
	lambda get : (Integer) -> T
	lambda length : () -> Integer
	lambda findIndex : T -> Integer = obj -> _findIndex(self, obj, 0, length);
	lambda slice : (Integer, Integer) -> _Slice[T] = (from, to) -> case {
		when (from < to) && (from >= 0) && (to <= length) : _Slice(self, from to);
		else error("index out of range.");
	}
}
lambda _findIndex[T] : (Array[T], T, Integer, Integer) -> Integer= (array, obj, from, to) -> {
	case {
		when from >= to : -1;
		when obj == array.get(from) : array.get(from);
		else : _findIndex(array, obj, from + 1);
	}
}

struct _Slice[T] : (array:Array[T], from:Integer, to:Integer) {
	val _array : Array[T] = array;
	val _from : Integer = from;
	val _to : Integer = to;
	lambda _length : () -> Integer = _to - from;

	@Lazy
	val length : Integer = _length();

	lambda get : Integer -> T = idx -> {
		case {
			when (idx < length) : _array.get(_from + idx);
			else : error("index out of range.");
		}
	}

	lambda findIndex : T -> Integer = obj -> {
		val idx = _findIndex(_array, obj, _from, _to);
		case idx {
			when -1 : -1;
			else _from + idx;
		}
	}

	lambda slice : (Integer, Integer) -> _Slice[T] = (from, to) -> case {
		when (from < to) && (from >= 0) && (to <= length) : _Slice(_array, _from + from, _from + from + to);
		else : error("index out of range.");
	}
}