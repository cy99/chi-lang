struct List[T] {
	val _value : T;
	val _rest default _nil[T]();

	lambda isEmpty : Boolean = false;
	lambda frontValue : T = _value;
	@lazy
	lambda hasRest : Boolean = self._rest != _nil[T]();
	lambda appendFront : T -> List[T] = obj -> List(obj, self);
	lambda first : T = self._value;
	lambda rest : List[T] = case hasRest {
		when true : _rest;
		when false : error("there is't rest.");
	}
	lambda map[E] : (T -> E) -> List[E] = m -> case hasRest {
		when true : List(m(_value), _rest.map(m));
		when false : List(m(_value));
	}
	lambda filter : (T -> Boolean) -> List[E] = m-> case m(_value) {
		when true : case hasRest {
			when true : List(_value, _rest.filter(m));
			when false : List(_value);
		}
		when false : case hasRest {
			when true : _rest.filter(m);
			when false : _nil[T]();
		}
	}
	lambda foldLeft : ((T, T) -> T) -> T = f -> case isEmpty {
		when true : error("empty List can not fold.");
		else : _reduce(self._rest, self._value, f);
	}
	lambda foldRight : ((T, T) -> T) -> T = f -> {
		lambda g : (T, T) -> T = (a, b) -> f(b, a);
		foldLeft(f);
	}
	lambda reduce[E] : (E, (E, T) -> E) -> E = (seed, f) -> _reduce(self, seed, f);
	lambda forEach : ((T)) = f -> _forEach(self, f);
}
lambda _forEach[T] : (List[T], (T)) = (lst, f) -> {
	f(lst._value);
	_foreach(lst._rest);
}
lambda _reduce[T, E] : (List[T], E, (E, T) -> E) -> E = (lst, seed, f) -> case lst.isEmpty {
	when true : seed;
	else : _reduce(lst._rest, f(seed, lst._value), f);
}
@Lazy
lambda _nil[T] : List[T];